# Пузырьковая сортировка (Bubble Sort)

> Большие элементы "всплывают" в конец массива как пузырьки, отсюда и название.

> Пузырьковая сортировка основана на сравнении соседних элементов и их перестановке, если они расположены неправильно относительно своего места в отсортированном списке. Проход по списку продолжается многократно, пока не завершится полный проход без единого обмена элементами.
## Алгоритм:
1. Просматриваем массив слева направо, сравнивая соседние элементы.
2. Если левый элемент больше правого, меняем их местами.
3. Повторяем шаги 1-2, пока список не станет упорядоченным.
## Пример реализации на python:
```python
def bubble_sort(arr):
    n = len(arr)
    # после каждого прохода самый большой элемент оказывается в конце
    for i in range(n):
        swapped = False  # если перетасовки не было - массив уже отсортирован
        # проходит по неотсортированной части массива
        for j in range(0, n-i-1):  # n-i — потому что последние i элементов уже на своих местах
            # cравниваем соседние элементы
            if arr[j] > arr[j+1]:
                # если левый больше меняем
                arr[j], arr[j+1] = arr[j+1], arr[j]
                swapped = True
        # если за весь проход не было ни одного обмена, значит массив уже отсортирован
        if not swapped:
            break
    return arr
```
### Визуализация работы
```
Исходный массив: [5, 1, 4, 2, 8]

Проход 1 (i=0, проверяем до n-0-1 = 4)
[5, 1, 4, 2, 8] → сравниваем 5 и 1 → меняем → [1, 5, 4, 2, 8]
[1, 5, 4, 2, 8] → сравниваем 5 и 4 → меняем → [1, 4, 5, 2, 8]
[1, 4, 5, 2, 8] → сравниваем 5 и 2 → меняем → [1, 4, 2, 5, 8]
[1, 4, 2, 5, 8] → сравниваем 5 и 8 → не меняем
Самый большой элемент (8) всплыл в конец ✓

Проход 2 (i=1, проверяем до n-1-1 = 3)
[1, 4, 2, 5, 8] → сравниваем 1 и 4 → не меняем
[1, 4, 2, 5, 8] → сравниваем 4 и 2 → меняем → [1, 2, 4, 5, 8]
[1, 2, 4, 5, 8] → сравниваем 4 и 5 → не меняем
Второй по величине (5) на месте ✓

Проход 3 (i=2, проверяем до n-2-1 = 2)
[1, 2, 4, 5, 8] → сравниваем 1 и 2 → не меняем
[1, 2, 4, 5, 8] → сравниваем 2 и 4 → не меняем
swapped = False! Выходим досрочно
```
## Использование и нюансы
Неэффективна для больших наборов данных. Её сложность составляет $O(n^2)$ в худшем и среднем случаях.
Редко используется для реальных задач.

Зачем - простая в написании и возможности раннего прерывания цикла, если массив уже частично отсортирован.

# Быстрая сортировка (QuickSort)

> Быстрая сортировка относится к категории алгоритмов "разделяй и властвуй". Основная идея заключается в выборе опорного элемента ("base"), после чего массив разделяется на две части: элементы меньше опорного и элементы больше опорного. Затем каждая часть сортируется отдельно.
## Алгоритм
1. Выбор опорного элемента.
2. Перестановка элементов вокруг опорного.
3. Рекурсивная сортировка обеих частей.
## Пример написания на Python
```python
def quick_sort(arr):

    if len(arr) <= 1:
        return arr
        
    base = arr[len(arr) // 2]
    
    left = [x for x in arr if x < base]
    middle = [x for x in arr if x == base]
    right = [x for x in arr if x > base]
    
    return quick_sort(left) + middle + quick_sort(right)
```
## Использование и нюансы
Эффективна для большинства случаев - средняя временной сложность $O(n\log{n})$. Быстрая сортировка предпочтительна для больших массивов.

Минусом является возможность худшего сценария ($O(n^2)$), возникающего при неудачном выборе опорного элемента (минимальный или максимальный элемент).
Поэтому можно выбрать другой элемент (середина или медиана).
