# Пузырьковая сортировка (Bubble Sort)

> Пузырьковая сортировка основана на сравнении соседних элементов и их перестановке, если они расположены неправильно относительно своего места в отсортированном списке. Проход по списку продолжается многократно, пока не завершится полный проход без единого обмена элементами.
## Алгоритм:
1. Просматриваем массив слева направо, сравнивая соседние элементы.
2. Если левый элемент больше правого, меняем их местами.
3. Повторяем шаги 1-2, пока список не станет упорядоченным.
## Пример реализации на python:
```python
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        swapped = False
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
                swapped = True
        if not swapped:
            break
    return arr
```
## Использование и нюансы
Неэффективна для больших наборов данных. Её сложность составляет $O(n^2)$ в худшем и среднем случаях.
Редко используется для реальных задач.

Зачем - простая в написании и возможности раннего прерывания цикла, если массив уже частично отсортирован.

# Быстрая сортировка (QuickSort)

> Быстрая сортировка относится к категории алгоритмов "разделяй и властвуй". Основная идея заключается в выборе опорного элемента ("base"), после чего массив разделяется на две части: элементы меньше опорного и элементы больше опорного. Затем каждая часть сортируется отдельно.
## Алгоритм
1. Выбор опорного элемента.
2. Перестановка элементов вокруг опорного.
3. Рекурсивная сортировка обеих частей.
## Пример написания на Python
```python
def quick_sort(arr):

    if len(arr) <= 1:
        return arr
        
    base = arr[len(arr) // 2]
    
    left = [x for x in arr if x < base]
    middle = [x for x in arr if x == base]
    right = [x for x in arr if x > base]
    
    return quick_sort(left) + middle + quick_sort(right)
```
## Использование и нюансы
Эффективна для большинства случаев - средняя временной сложность $O(n\log{n})$. Быстрая сортировка предпочтительна для больших массивов.

Минусом является возможность худшего сценария ($O(n^2)$), возникающего при неудачном выборе опорного элемента (минимальный или максимальный элемент).
Поэтому можно выбрать другой элемент (середина или медиана).