> Делают код гибким, понятным и удобным для поддержки.

**SOLID** — акроним пяти принципов объектно-ориентированного проектирования Роберта Мартина:

### 1. S — Single Responsibility Principle (Принцип единственной ответственности)
«У класса должна быть только одна причина для изменения».
*   **Суть:** Класс должен решать только одну конкретную задачу.
*   **Зачем:** Если класс делает слишком много, изменения в одной функции могут сломать другие. Код проще тестировать и читать.

### 2. O — Open/Closed Principle (Принцип открытости/закрытости)
«Классы должны быть открыты для расширения, но закрыты для модификации».
*   **Суть:** Вы должны иметь возможность добавить новую функциональность классу, не переписывая его существующий код (например, через наследование или интерфейсы).
*   **Зачем:** Чтобы не сломать уже работающий старый код при добавлении новых фич.

### 3. L — Liskov Substitution Principle (Принцип подстановки Барбары Лисков)
«Функции, которые используют базовый тип, должны иметь возможность использовать его подтипы, не зная об этом».
*   **Суть:** Объекты дочернего класса должны полностью заменять объекты родительского класса, не ломая логику программы. Дочерний класс не должен удалять методы родителя или менять их поведение до неузнаваемости.
*   **Пример:** Если у вас есть класс «Птица» с методом «Летать», а вы создаете подкласс «Пингвин» (который не летает), вы нарушаете этот принцип.

### 4. I — Interface Segregation Principle (Принцип разделения интерфейсов)
«Лучше много специализированных интерфейсов, чем один общий».
*   **Суть:** Не заставляйте класс реализовывать методы, которые ему не нужны. Разбивайте «толстые» интерфейсы на маленькие и узкоспециализированные.
*   **Зачем:** Чтобы классы не содержали «мертвый» код (пустые заглушки методов, которые они не должны выполнять).

### 5. D — Dependency Inversion Principle (Принцип инверсии зависимостей)
«Зависимости должны строиться на абстракциях, а не на конкретных деталях».
*   **Суть:** Модули верхнего уровня (бизнес-логика) не должны зависеть от модулей нижнего уровня (базы данных, API). И те, и другие должны зависеть от абстракций (интерфейсов).
*   **Зачем:** Уменьшает связанность кода. Вы можете легко заменить базу данных или способ отправки уведомлений, не переписывая всю основную логику приложения.

Какие проблемы решает:
- Сильно связанные классы: изменение одного затрагивает другие.
- Трудности с тестированием: компоненты тесно связаны друг с другом, из-за чего их сложно тестировать по отдельности.
- Проблемы с масштабированием: добавление новых функций часто приводит к переработке уже работающего кода.
- Неустойчивость к изменениям: одна правка может сломать всё приложение.