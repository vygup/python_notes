Объектно ориентированное программирование - программы состоят из объектов. Объект - сущность, обладающая собственными данными и набором разрешенных действий:
- Строятся по шаблону (класс)
- Сами отвечают за свое состояние и его целостность (инкапсуляция)
- Предоставляют стабильный контракт, не зависящий от внутреннего устройства ("программируй на интерфейсах, а не на реализациях” - изменения внутри класса не ломают внешний код)

>Объекты — это “строительные блоки”, моделирующие реальный мир: каждый имеет состояние (данные) и поведение (методы).

 Другая часто используемая парадигма - функциональная - все начинается с функций и объект уже будет результатом отработки функции
> Это проще, но при большом объеме кода будут сложности из-за разрозненности функций

# Структура:

## Класс 

>это шаблон или "чертеж", который определяет структуру и поведение объектов определенного типа. Класс описывает, какие данные (атрибуты) будут содержать объекты и какие операции (методы) они смогут выполнять.

Шаблон (общая абстракция, которая описывает структуру объектов), на базе которого можно построить объект. Классы могут наследоваться друг от друга. Подкласс берет свойства родительского класса, но также дополняется своими свойствами

Основные элементы, которые определяются в классе:

1. **Имя класса** — имя должно следовать соглашению PascalCase (каждое слово с большой буквы, без подчеркиваний)
2. **Документация** — строка документации, описывающая назначение класса
3. **Конструктор** — специальный метод __init__, который вызывается при создании нового экземпляра
4. **Атрибуты** — переменные, хранящие данные класса или экземпляра
5. **Методы** — функции, определенные внутри класса, которые могут работать с атрибутами класса

## Объект

Объект (или экземпляр класса) — это конкретная реализация класса, созданная в памяти. Каждый объект имеет свое уникальное состояние (значения атрибутов) и может выполнять поведение, определенное в классе (методы).

Часть кода, которая описывает элемент с конкретными функциями и характеристиками (создается вызовом класса)

Важно:
- Каждый объект имеет свое собственное состояние (значения атрибутов)
- Все объекты одного класса имеют одинаковый набор методов
- Изменение атрибутов одного объекта не влияет на другие объекты

## Метод

Функция (def) внутри объекта или класса, которая позволяет взаимодействовать с ним или другой частью кода

## Атрибут

Характеристики объекта (присвоенное переменной значение)

# Пример:

```python
class Book:  # класс
	# специальынй метод (конструктор или инициализатор)
    def __init__(self, title, author):
	    # атрибуты
        self.title = title
        self.author = author
	# метода вывода описания
    def describe(self):  # метод
        print(f'"{self.title}", {self.author}')

# инстанцировать класс
book1 = Book('name', 'author')  # объект
```

Более практический пример:
```python
class BankAccount:
    def __init__(self, owner, balance=0):
        self.owner = owner
        self.balance = balance

    def deposit(self, amount):
        if amount > 0:
            self.balance += amount
            return f"Внесено {amount} руб. Новый баланс: {self.balance} руб."
        return "Сумма депозита должна быть положительной"

    def withdraw(self, amount):
        if amount > 0:
            if amount <= self.balance:
                self.balance -= amount
                return f"Снято {amount} руб. Новый баланс: {self.balance} руб."
            return "Недостаточно средств"
        return "Сумма снятия должна быть положительной"

    def get_balance(self):
        return f"Баланс счета {self.owner}: {self.balance} руб."

# Создаем банковский счет
account = BankAccount("Иван Петров", 1000)

# Используем методы счета
print(account.get_balance())
print(account.deposit(500))
print(account.withdraw(200))
print(account.withdraw(2000))  # Попытка снять больше, чем есть на счете
```
```
Баланс счета Иван Петров: 1000 руб.
Внесено 500 руб. Новый баланс: 1500 руб.
Снято 200 руб. Новый баланс: 1300 руб.
Недостаточно средств
```

# `self` и `object`

`self` – общепринятое имя для ссылки на объект, в контексте которого вызывается метод. Этот параметр обязателен и отличает метод класса от обычной функции.

- self автоматически передается при вызове метода через объект
- Через self мы получаем доступ к атрибутам и другим методам экземпляра
- Хотя имя self не является обязательным, это общепринятое соглашение в Python

`object`  - это и тип данных (родитель всех типов и классов), и базовый класс всех классов в Python.

# Принципы:

## Инкапсуляция

Объединение данных и методов, которые работают с этими данными, в единый объект и скрытие деталей реализации. Отвечает на вопрос - как именно можно работать с данными объекта.
Суть - вся информация, которая нужна для работы конкретного объекта, должна храниться внутри этого объекта.
- Если нужно вносить изменения, методы для этого тоже должны лежать в самом объекте — посторонние объекты и классы этого делать не могут. Внешний интерфейс объекта должен быть отделен от его внутреннего состояния.
- Инкапсуляция обеспечивает безопасность и не даёт повредить данные внутри какого-то класса со стороны. Ещё он помогает избежать случайных зависимостей, когда из-за изменения одного объекта что-то ломается в другом.

Атрибут может быть объявлен приватным (внутренним) с помощью нижнего подчеркивания перед именем, но настоящего скрытия на самом деле не происходит – все на уровне соглашений.

```python
class SomeClass:
    def _private(self):
        print("Это внутренний метод объекта")

obj = SomeClass()
obj._private() # это внутренний метод объекта
```

Если поставить перед именем атрибута два подчеркивания, к нему нельзя будет обратиться напрямую. Но все равно остается обходной путь:

```python
class SomeClass():
    def __init__(self):
        self.__param = 42 # защищенный атрибут

obj = SomeClass()
obj.__param # AttributeError: 'SomeClass' object has no attribute '__param'
obj._SomeClass__param # 42
```

## Наследование
> (суть ООП)

Создание новых классов на основе существующих классов с сохранением их свойств и методов.
Каждый дочерний элемент наследует методы и атрибуты, прописанные в родительском. Он может использовать их все (не дублируя код), отбросить часть или добавить новые.
Классы-родители передаются в скобки класса через запятую

## Полиморфизм

Возможность использовать объекты с одинаковыми интерфейсами без информации о типе и внутренней структуре объекта
Метод вызывается одинаково, но результат может отличаться потому что объекты относятся к разным классам и внутри класса он может быть изменен.
В этом суть полиморфизма: один и тот же метод используется одинаковым образом, но ведёт себя по-разному в зависимости от типа объекта.

## Абстракция

Выделение важных характеристик объекта и игнорирование несущественных деталей

# Преимущества и недостатки ООП

## Преимущества:

- **В парадигме объектов легче писать код.** Удобно один раз создать класс или метод, а потом его использовать. Не нужно повторно переписывать десятки строк кода. Можно пользоваться специальными рекомендациями по написанию ООП-кода — SOLID. 
- **Читать код гораздо проще.** Даже в чужом коде обычно сразу видны конкретные объекты и методы, их удобно искать, чтобы посмотреть, что именно они делают. 
- **Код легче обновлять.** Класс или метод достаточно изменить в одном месте, чтобы он изменился во всех наследуемых классах и объектах. Не нужно переписывать каждый объект отдельно, выискивая, где именно в коде он расположен. 
- **Программистам удобнее работать в команде.** Разные люди могут отвечать за разные объекты и при этом пользоваться плодами трудов коллег. 
- **Код можно переиспользовать.** Один раз написанный класс или объект можно затем переносить в другие проекты. Достаточно однажды написать объект «Кнопка заказа» и потом можно вставлять его в почти неизменном виде в разные каталоги товаров и мобильные приложения. 
- **Шаблоны проектирования.** Именно на базе ООП построены готовые решения для взаимодействия классов друг с другом, которые позволяют не писать этот код с нуля, а взять шаблон.

## Недостатки:

- **Сложность в освоении.** ООП сложнее, чем функциональное программирование. Для написания кода в этой парадигме нужно знать гораздо больше. Поэтому перед созданием первой рабочей программы придётся освоить много информации: разобраться в классах и наследовании, научиться писать публичные и внутренние функции, изучить способы взаимодействия объектов между собой. 
- **Громоздкость.** Там, где в функциональном программировании хватит одной функции, в ООП нужно создать класс, объект, методы и атрибуты. Для больших программ это плюс, так как структура будет понятной, а для маленьких может оказаться лишней тратой времени. 
- **Низкая производительность.** Объекты потребляют больше памяти, чем простые функции и переменные. Скорость компиляции от этого тоже страдает.

>Получается, что основная функция объектно-ориентированного программирования — облегчить написание больших, сложных программ, над которыми трудятся группы разработчиков.

# Специальные методы

>В Python есть методы, которые мы обычно не вызываем напрямую. Их запускает сам интерпретатор — в определённых ситуациях, когда объект используется тем или иным образом.

`__init__` - специальный метод (конструктор или инициализатор), вызывается в тот момент, когда мы создаём новый объект класса. Его задача — задать начальное состояние объекта: сохранить данные, с которыми он будет дальше работать.

`__dict__` - все пользовательские атрибуты сохраняются в атрибуте , который является словарем. Корень всей иерархии.

`__new__` - непосредственно создает новый экземпляр класса. Первым параметром он принимает ссылку на сам класс:
```python
class SomeClass:
    def __new__(cls):
        print("new")
        return super(SomeClass, cls).__new__(cls)

    def __init__(self):
        print("init")

obj = SomeClass();
# new
# init
```

`__del__` - метод-деструктор - удаление объекта

`__call__` - объект класса может имитировать стандартную функцию, то есть при желании его можно "вызвать" с параметрами. За эту возможность отвечает специальный метод:
```python
class Multiplier:
    def __call__(self, x, y):
        return x*y

multiply = Multiplier()
multiply(19, 19) # 361
# то же самое
multiply.__call__(19, 19) # 361
```

`__str__` - чтобы задать осмысленное текстовое представление объекта, в классе используют специальный метод.
```python
class Character:
	def __init__(self, name, health):
		self.name = name
		self.health = health

	def __str__(self):
		return f"{self.name} (здоровье: {self.health})"
```

# Статические и классовые методы

Для создания **статических** методов в Python предназначен декоратор `@staticmethod`. У них нет обязательных параметров-ссылок вроде `self`. Доступ к таким методам можно получить как из экземпляра класса, так и из самого  класса:

```python
class SomeClass:
    @staticmethod
    def hello():
        print("Hello, world")

SomeClass.hello() # Hello, world
obj = SomeClass()
obj.hello() # Hello, world
```

Еще есть так называемые **методы классов**. Они аналогичны методам экземпляров, но выполняются не в контексте объекта, а в контексте самого класса  (классы – это тоже объекты). Такие методы создаются с помощью декоратора `@classmethod` и требуют обязательную ссылку на класс (`cls`).

```python
class SomeClass:
    @classmethod
    def hello(cls):
        print('Hello, класс {}'.format(cls.__name__))

SomeClass.hello() # Hello, класс SomeClass
```

Статические и классовые методы доступны без инстанцирования.

# Главное об ООП

1. ООП — это парадигма разработки, набор правил и критериев, по которым пишут код. Её суть в том, что весь код состоит из объектов, которые взаимодействуют друг с другом. Существуют и другие парадигмы, например, функциональное программирование.
2. В ООП выделяют четыре основных элемента: классы, объекты, методы и атрибуты.
3. Объектно-ориентированный подход к программированию строится на трёх основных принципах: наследование, инкапсуляция и полиморфизм.
4. Программы, созданные по принципам ООП, более структурированные, легче читаются и хорошо масштабируются. При этом они сложнее в написании.