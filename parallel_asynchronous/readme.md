> Чтобы справляться с множеством задач "одновременно", можно использовать подходы, относящиеся к **конкурентному выполнению (Concurrency)**.

# Конкурентное выполнение `Concurrency`

Свойство системы, при котором несколько вычислительных процессов или задач могут выполняться, не обязательно одновременно, но с возможностью переключения между ними. Это позволяет программе оставаться отзывчивой и эффективно использовать ресурсы, особенно во время ожидания.

Без использования подходов, Python использует только одно ядро и один поток для выполнения программы.

## Параллелизм и асинхронность
> Это два подхода добиться конкурентного поведения программы

### Параллелизм (Parallelism)

Две или более задачи выполняются _одновременно (параллельно)_ в один и тот же момент времени. Для этого необходима аппаратная поддержка (многоядерный процессор).

### Асинхронность (Asynchronicity)

Способ организации программы, при котором задача, начав операцию, требующую ожидания (например, запрос к базе данных), не блокирует всю программу, а позволяет ей переключиться на выполнение других задач. Когда ожидаемая операция завершается, программа может вернуться к исходной задаче.
Это достигается на одном потоке выполнения.

### Ключевое отличие
- **Параллелизм** — это про _одновременное делание_ нескольких вещей (требует нескольких "исполнителей", например, ядер процессора).
- **Асинхронность** — это про _структурирование работы_ так, чтобы не простаивать в ожидании (один "исполнитель" эффективно переключается между задачами).

## Процесс и потоки
> Два механизма для достижения конкурентности на уровне операционной системы

### Процесс (Process)
> 1 процесс = 1 ядро

Независимая программа, выполняемая операционной системой. Каждый процесс имеет свое собственное адресное пространство памяти. Обмен данными между процессами сложнее (требует механизмов межпроцессного взаимодействия, IPC), но они более изолированы друг от друга.

### Поток (Thread)

Наименьшая единица выполнения внутри процесса. Один процесс может содержать несколько потоков, которые разделяют общее адресное пространство памяти этого процесса. Это упрощает обмен данными между потоками, но требует осторожности для избежания конфликтов доступа к общим данным (состояния гонки).

## Встроенные модули и концепции для реализации конкурентности

### Модуль `threading`

- Предоставляет инструменты для создания и управления **потоками** внутри одного процесса.
- Потоки разделяют общую память, что потенциально упрощает обмен данными (но требует синхронизации).
- GIL освобождается во время выполнения блокирующих операций ввода/вывода (например, ожидание сети, чтение с диска). В это время другие потоки могут получить GIL и выполняться.
- Видимость параллельности создается из-за скорости передачи GIL ~5 мс (`sys.setswitchinterval()`).
- Класс `queue.Queue` реализует очередь, защищённую от гонки данных (безопасный механизм передачи данных между потоками). Потоки могут добавлять или извлекать элементы из очереди синхронно и безопасно.

#### Риски

- Потоки конкурируют за доступ к общим ресурсам (`race conditions`).
- Если два или больше потоков пытаются одновременно изменить общую переменную, возможно нарушение целостности данных.
- Есть риск взаимоблокировки (deadlocks), возникающей, когда два потока ожидают освобождения ресурса друг друга.

#### Пример реализации на Python
```python
import threading
import time

def countdown_timer(seconds):
    """Таймер в параллельном потоке"""
    
    for i in range(seconds, 0, -1):
        print(f"Таймер: {i} сек")
        time.sleep(1)

timer_thread = threading.Thread(target=countdown_timer, args=(5,))
timer_thread.daemon = True  # для завершения потока с программой или .join()
timer_thread.start()

print("Другая работа - sleep(3)")
time.sleep(3)
print("sleep(3) закончен")
```

### Модуль `asyncio` (ключевые слова `async`/`await`)

- Предлагает инфраструктуру для **асинхронного** программирования с использованием **корутин (coroutine)** и цикла событий в **одном потоке**.
	`Корутины (coroutines)` - функции, которые могут приостанавливать своё выполнение, позволяя другому коду выполняться, и затем возобновлять работу с того места, где они остановились
#### Пример реализации на Python
```python
import aiohttp
import asyncio

async def fetch_url(session, url):
    """Загрузка одного URL"""
    async with session.get(url) as response:
        return await response.text()

async def async_fetch_urls():
    """Асинхронное выполнение"""
    urls = [
        'https://ya.ru',
        'https://google.com',
        'https://duckduckgo.com',
    ]
	
    async with aiohttp.ClientSession() as session:
        # собираем задачи для выполнения
        tasks = [fetch_url(session, url) for url in urls]
        
        # запускаем все задачи одновременно
        results = await asyncio.gather(*tasks)
	
    return results
    
# запуск
# if __name__ == "__main__":
#     results = asyncio.run(async_fetch_urls())

# в jupyter
res = await async_fetch_urls()
```

### Модуль `multiprocessing`

- Позволяет создавать и управлять отдельными **процессами**.
- Каждый процесс имеет свой собственный интерпретатор Python и свою память, что обеспечивает изоляцию.
- У каждого процесса свой GIL
#### Пример реализации на Python
```python
# в отдельный_файл py
def cpu_bound_task(n):
    """Задача с вычислениями"""
    
    count = 0
    for i in range(50_000_000):
        count += i
    return count
```

``` python
import multiprocessing
from отдельный_файл import cpu_bound_task

# использует 4 ядра процессора
def parallel_tasks():
"""Многопроцессорное использование"""
	multiprocessing.freeze_support() # Windows/Jupyter
	with multiprocessing.Pool(processes=4) as pool:
		result = pool.map(cpu_bound_task, range(4))
	return result

# запуск
if __name__ == "__main__":
	result = parallel_tasks()
```

### Сравнение

| Аспект                 | Синхронный                                                                                    | Многопоточный                                                       | Асинхронный                                                    | Многопроцессный                  |
| ---------------------- | --------------------------------------------------------------------------------------------- | ------------------------------------------------------------------- | -------------------------------------------------------------- | -------------------------------- |
| **Ресурсы**            | 1 ядро, 1 поток                                                                               | 1 ядро (из-за GIL), каждый поток требует RAM (~8MB)                 | 1 ядро, 1 поток почти не требует памяти                        | Много ядер, по 1 потоку          |
| **Когда использовать** | Простые скрипты, последовательные задачи                                                      | IO-задачи (сеть, диски)                                             | Много ожиданий                                                 | CPU-задачи (вычисления)          |
| **Пример**             | Обработка одного файла                                                                        | Загрузка многих файлов                                              | Веб-сервер, API запросы                                        | Обработка изображений/данных     |
| **Преимущества**       | Многопоточность тратит время на ожидание GIL вместо вычислений — итог медленнее одного потока | GUI-приложения, старые блокирующие библиотеки, I/O-задачи, простота | Современные I/O-задачи, тысячи соединений (веб), новые проекты | Реальные параллельные вычисления |

## Global Interpreter Lock (GIL)
> Глобальный блокировщик интерпретатора

`GIL` - это мьютекс (mutex), который защищает доступ к объектам Python, предотвращая одновременное выполнение байт-кода Python несколькими потоками _в рамках одного процесса_. Только поток, удерживающий GIL, может выполнять байт-код.
